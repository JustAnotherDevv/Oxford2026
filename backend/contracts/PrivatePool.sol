// SPDX-License-Identifier: MIT
pragma solidity ^0.8.27;

import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {HonkVerifier} from "./plonk_vk.sol"; // generated by: bb write_solidity_verifier

/// @title PrivatePool - Shielded token pool with relayer support
/// @notice Users deposit ERC-20 tokens into a shielded UTXO pool, then transfer
///         privately inside it using ZK proofs. A relayer can submit transactions
///         on behalf of users (gasless), taking a fee from the shielded amount.
///
/// Public inputs layout (7 fields, matches the Noir circuit):
///   [0] merkle_root
///   [1] nullifier_1
///   [2] nullifier_2
///   [3] out_commitment_1
///   [4] out_commitment_2
///   [5] fee
///   [6] relayer
contract PrivatePool {
    // ===================== State =====================

    HonkVerifier public immutable verifier;
    IERC20 public immutable token;

    uint256 public constant TREE_DEPTH = 20;
    uint256 public constant MAX_LEAVES = 2 ** TREE_DEPTH;

    // Merkle tree (incremental, append-only)
    uint256 public nextLeafIndex;
    mapping(uint256 => bytes32) public filledSubtrees;
    mapping(uint256 => bytes32) public roots; // historical roots
    uint256 public currentRootIndex;
    uint256 public constant ROOT_HISTORY_SIZE = 100;

    bytes32[TREE_DEPTH] public zeros; // precomputed zero hashes per level

    // Nullifier set (spent notes)
    mapping(bytes32 => bool) public nullifierUsed;

    // ===================== Events =====================

    event Deposit(bytes32 indexed commitment, uint256 leafIndex, uint256 amount);
    event Transact(bytes32 nullifier1, bytes32 nullifier2, bytes32 commitment1, bytes32 commitment2);
    event Withdrawal(bytes32 indexed nullifier, address indexed to, uint256 amount);

    // ===================== Constructor =====================

    constructor(address _verifier, address _token) {
        verifier = HonkVerifier(_verifier);
        token = IERC20(_token);

        // Initialize zero hashes for empty tree
        // zeros[0] = hash of an empty leaf (0)
        bytes32 currentZero = bytes32(0);
        for (uint256 i = 0; i < TREE_DEPTH; i++) {
            zeros[i] = currentZero;
            filledSubtrees[i] = currentZero;
            currentZero = _hashPair(currentZero, currentZero);
        }
        roots[0] = currentZero; // empty tree root
    }

    // ===================== Deposit (Shield) =====================

    /// @notice Deposit tokens and create a shielded note
    /// @param commitment The Pedersen commitment H(value, secret, owner)
    /// @param amount The token amount to shield
    /// @dev User computes commitment off-chain and keeps (secret, owner) private
    function deposit(bytes32 commitment, uint256 amount) external {
        require(amount > 0, "Zero amount");
        require(nextLeafIndex < MAX_LEAVES, "Tree full");

        token.transferFrom(msg.sender, address(this), amount);

        uint256 leafIndex = nextLeafIndex;
        _insertLeaf(commitment);

        emit Deposit(commitment, leafIndex, amount);
    }

    // ===================== Transact (Private Transfer inside pool) =====================

    /// @notice Execute a private transaction inside the shielded pool
    /// @param proof The ZK proof generated by the Noir circuit
    /// @param publicInputs The 7 public inputs [root, null1, null2, comm1, comm2, fee, relayer]
    /// @dev Can be called by anyone (relayer or user directly).
    ///      The relayer address is baked into the proof - if msg.sender != relayer,
    ///      the fee still goes to the committed relayer address.
    function transact(bytes calldata proof, bytes32[] calldata publicInputs) external {
        require(publicInputs.length == 7, "Bad public inputs");

        bytes32 merkleRoot = publicInputs[0];
        bytes32 nullifier1 = publicInputs[1];
        bytes32 nullifier2 = publicInputs[2];
        bytes32 commitment1 = publicInputs[3];
        bytes32 commitment2 = publicInputs[4];
        uint256 fee = uint256(publicInputs[5]);
        address relayer = address(uint160(uint256(publicInputs[6])));

        // Check Merkle root is known (current or recent)
        require(_isKnownRoot(merkleRoot), "Unknown root");

        // Check nullifiers haven't been spent
        require(!nullifierUsed[nullifier1], "Nullifier 1 spent");
        require(!nullifierUsed[nullifier2], "Nullifier 2 spent");

        // Verify the ZK proof
        require(verifier.verify(proof, publicInputs), "Invalid proof");

        // Mark nullifiers as spent
        nullifierUsed[nullifier1] = true;
        nullifierUsed[nullifier2] = true;

        // Insert new commitments into the tree
        _insertLeaf(commitment1);
        _insertLeaf(commitment2);

        // Pay relayer fee (if any)
        if (fee > 0 && relayer != address(0)) {
            token.transfer(relayer, fee);
        }

        emit Transact(nullifier1, nullifier2, commitment1, commitment2);
    }

    // ===================== Withdraw (Unshield) =====================

    /// @notice Withdraw tokens from the pool by proving note ownership
    /// @param proof The ZK proof
    /// @param publicInputs The 7 public inputs
    /// @param recipient Address to receive the unshielded tokens
    /// @param withdrawAmount Amount to withdraw (must match output note value)
    /// @dev Uses the same circuit as transact. One output is the "withdraw" note
    ///      (value = withdrawAmount), the other is change back into the pool.
    ///      The withdraw note's commitment is still inserted into the tree,
    ///      but the contract also releases tokens to the recipient.
    function withdraw(
        bytes calldata proof,
        bytes32[] calldata publicInputs,
        address recipient,
        uint256 withdrawAmount
    ) external {
        require(publicInputs.length == 7, "Bad public inputs");
        require(recipient != address(0), "Bad recipient");
        require(withdrawAmount > 0, "Zero withdraw");

        bytes32 merkleRoot = publicInputs[0];
        bytes32 nullifier1 = publicInputs[1];
        bytes32 nullifier2 = publicInputs[2];
        bytes32 commitment1 = publicInputs[3];
        bytes32 commitment2 = publicInputs[4];
        uint256 fee = uint256(publicInputs[5]);
        address relayer = address(uint160(uint256(publicInputs[6])));

        require(_isKnownRoot(merkleRoot), "Unknown root");
        require(!nullifierUsed[nullifier1], "Nullifier 1 spent");
        require(!nullifierUsed[nullifier2], "Nullifier 2 spent");

        require(verifier.verify(proof, publicInputs), "Invalid proof");

        nullifierUsed[nullifier1] = true;
        nullifierUsed[nullifier2] = true;

        // Insert output commitments (change note stays in the pool)
        _insertLeaf(commitment1);
        _insertLeaf(commitment2);

        // Release tokens to the recipient
        token.transfer(recipient, withdrawAmount);

        // Pay relayer fee
        if (fee > 0 && relayer != address(0)) {
            token.transfer(relayer, fee);
        }

        emit Withdrawal(nullifier1, recipient, withdrawAmount);
    }

    // ===================== Merkle tree internals =====================

    function _insertLeaf(bytes32 leaf) internal {
        uint256 index = nextLeafIndex;
        require(index < MAX_LEAVES, "Tree full");

        bytes32 currentHash = leaf;
        bytes32 left;
        bytes32 right;

        for (uint256 i = 0; i < TREE_DEPTH; i++) {
            if (index % 2 == 0) {
                left = currentHash;
                right = zeros[i];
                filledSubtrees[i] = currentHash;
            } else {
                left = filledSubtrees[i];
                right = currentHash;
            }
            currentHash = _hashPair(left, right);
            index /= 2;
        }

        nextLeafIndex++;
        currentRootIndex = (currentRootIndex + 1) % ROOT_HISTORY_SIZE;
        roots[currentRootIndex] = currentHash;
    }

    function _isKnownRoot(bytes32 root) internal view returns (bool) {
        if (root == bytes32(0)) return false;
        uint256 i = currentRootIndex;
        for (uint256 j = 0; j < ROOT_HISTORY_SIZE; j++) {
            if (roots[i] == root) return true;
            if (i == 0) i = ROOT_HISTORY_SIZE - 1;
            else i--;
        }
        return false;
    }

    /// @dev Pedersen hash pair - must match the Noir circuit's pedersen_hash.
    ///      In production, use a precompile or Yul implementation of the
    ///      same Pedersen hash used by Noir's backend.
    ///      For hackathon/testing, you can substitute with keccak256
    ///      as long as both circuit and contract use the same hash.
    function _hashPair(bytes32 left, bytes32 right) internal pure returns (bytes32) {
        // TODO: Replace with Pedersen hash matching Noir's implementation.
        // For now using keccak256 as placeholder - the verifier contract
        // handles the actual proof verification; this is only for the
        // on-chain Merkle tree which must match what the circuit proves against.
        return keccak256(abi.encodePacked(left, right));
    }

    // ===================== View helpers =====================

    function getLastRoot() external view returns (bytes32) {
        return roots[currentRootIndex];
    }
}
