{"noir_version":"1.0.0-beta.6+e796dfd67726cbc28eb9991782533b211025928d","hash":"17364127710660018558","abi":{"parameters":[{"name":"merkle_root","type":{"kind":"field"},"visibility":"public"},{"name":"nullifier_1","type":{"kind":"field"},"visibility":"public"},{"name":"nullifier_2","type":{"kind":"field"},"visibility":"public"},{"name":"out_commitment_1","type":{"kind":"field"},"visibility":"public"},{"name":"out_commitment_2","type":{"kind":"field"},"visibility":"public"},{"name":"fee","type":{"kind":"field"},"visibility":"public"},{"name":"relayer","type":{"kind":"field"},"visibility":"public"},{"name":"encrypted_value_1","type":{"kind":"field"},"visibility":"public"},{"name":"encrypted_value_2","type":{"kind":"field"},"visibility":"public"},{"name":"in_value_1","type":{"kind":"field"},"visibility":"private"},{"name":"in_secret_1","type":{"kind":"field"},"visibility":"private"},{"name":"in_owner_1","type":{"kind":"field"},"visibility":"private"},{"name":"in_leaf_index_1","type":{"kind":"field"},"visibility":"private"},{"name":"in_path_1","type":{"kind":"array","length":20,"type":{"kind":"field"}},"visibility":"private"},{"name":"in_dirs_1","type":{"kind":"array","length":20,"type":{"kind":"field"}},"visibility":"private"},{"name":"in_is_dummy_1","type":{"kind":"field"},"visibility":"private"},{"name":"in_value_2","type":{"kind":"field"},"visibility":"private"},{"name":"in_secret_2","type":{"kind":"field"},"visibility":"private"},{"name":"in_owner_2","type":{"kind":"field"},"visibility":"private"},{"name":"in_leaf_index_2","type":{"kind":"field"},"visibility":"private"},{"name":"in_path_2","type":{"kind":"array","length":20,"type":{"kind":"field"}},"visibility":"private"},{"name":"in_dirs_2","type":{"kind":"array","length":20,"type":{"kind":"field"}},"visibility":"private"},{"name":"in_is_dummy_2","type":{"kind":"field"},"visibility":"private"},{"name":"out_value_1","type":{"kind":"field"},"visibility":"private"},{"name":"out_secret_1","type":{"kind":"field"},"visibility":"private"},{"name":"out_owner_1","type":{"kind":"field"},"visibility":"private"},{"name":"out_value_2","type":{"kind":"field"},"visibility":"private"},{"name":"out_secret_2","type":{"kind":"field"},"visibility":"private"},{"name":"out_owner_2","type":{"kind":"field"},"visibility":"private"},{"name":"out_viewing_key_1","type":{"kind":"field"},"visibility":"private"},{"name":"out_viewing_key_2","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{"68522319755051195":{"error_kind":"string","string":"Amounts do not balance"},"2558533842606529937":{"error_kind":"string","string":"Input 1: Merkle proof invalid"},"2976883394379558481":{"error_kind":"string","string":"Input 1: nullifier mismatch"},"4234315635844523824":{"error_kind":"string","string":"Dummy input 1 must have zero value"},"4461014769498708153":{"error_kind":"string","string":"Dummy input 2 must have zero value"},"6485997221020871071":{"error_kind":"string","string":"call to assert_max_bit_size"},"8535758295395481143":{"error_kind":"string","string":"Output 2: commitment mismatch"},"10436347462486260712":{"error_kind":"string","string":"Input 2: nullifier mismatch"},"11649769938841116436":{"error_kind":"string","string":"Duplicate nullifier"},"14231140584637917929":{"error_kind":"string","string":"Input 2: Merkle proof invalid"},"14933059949521733979":{"error_kind":"string","string":"Encrypted value 2 mismatch"},"16321636898482724197":{"error_kind":"string","string":"Encrypted value 1 mismatch"},"17381577670988517435":{"error_kind":"string","string":"Dummy flag must be 0 or 1"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"},"18103834484826132249":{"error_kind":"string","string":"Direction must be 0 or 1"},"18288820230573810737":{"error_kind":"string","string":"Output 1: commitment mismatch"}}},"bytecode":"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","debug_symbols":"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","file_map":{"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"50":{"source":"use std::hash::pedersen_hash;\n\npub fn compute_commitment(value: Field, secret: Field, owner: Field) -> Field {\n    pedersen_hash([value, secret, owner])\n}\n\npub fn compute_nullifier(secret: Field, leaf_index: Field) -> Field {\n    pedersen_hash([secret, leaf_index])\n}\n\npub fn compute_encrypted_value(value: Field, viewing_key: Field, commitment: Field) -> Field {\n    value + pedersen_hash([viewing_key, commitment])\n}\n\npub fn verify_merkle_proof<let N: u32>(\n    leaf: Field,\n    _leaf_index: Field,\n    path: [Field; N],\n    directions: [Field; N],\n) -> Field {\n    let mut current = leaf;\n\n    for i in 0..N {\n        let sibling = path[i];\n        let dir = directions[i];\n\n        assert((dir == 0) | (dir == 1), \"Direction must be 0 or 1\");\n\n        let (left, right) = if dir == 0 {\n            (current, sibling)\n        } else {\n            (sibling, current)\n        };\n\n        current = pedersen_hash([left, right]);\n    }\n\n    current\n}\n\n#[test]\nfn test_commitment_is_deterministic() {\n    let c1 = compute_commitment(100, 42, 1);\n    let c2 = compute_commitment(100, 42, 1);\n    assert(c1 == c2);\n}\n\n#[test]\nfn test_commitment_changes_with_different_inputs() {\n    let c1 = compute_commitment(100, 42, 1);\n    let c2 = compute_commitment(101, 42, 1);\n    let c3 = compute_commitment(100, 43, 1);\n    let c4 = compute_commitment(100, 42, 2);\n    assert(c1 != c2);\n    assert(c1 != c3);\n    assert(c1 != c4);\n}\n\n#[test]\nfn test_nullifier_is_deterministic() {\n    let n1 = compute_nullifier(42, 0);\n    let n2 = compute_nullifier(42, 0);\n    assert(n1 == n2);\n}\n\n#[test]\nfn test_nullifier_changes_with_different_inputs() {\n    let n1 = compute_nullifier(42, 0);\n    let n2 = compute_nullifier(43, 0);\n    let n3 = compute_nullifier(42, 1);\n    assert(n1 != n2);\n    assert(n1 != n3);\n}\n\n#[test]\nfn test_merkle_proof_depth_2() {\n    let leaf0 = compute_commitment(100, 1, 1);\n    let leaf1 = compute_commitment(200, 2, 2);\n    let leaf2 = compute_commitment(300, 3, 3);\n    let leaf3 = compute_commitment(400, 4, 4);\n\n    let node0 = pedersen_hash([leaf0, leaf1]);\n    let node1 = pedersen_hash([leaf2, leaf3]);\n    let root = pedersen_hash([node0, node1]);\n\n    let computed = verify_merkle_proof(leaf0, 0, [leaf1, node1], [0, 0]);\n    assert(computed == root);\n\n    let computed1 = verify_merkle_proof(leaf1, 1, [leaf0, node1], [1, 0]);\n    assert(computed1 == root);\n\n    let computed3 = verify_merkle_proof(leaf3, 3, [leaf2, node0], [1, 1]);\n    assert(computed3 == root);\n}\n\n#[test(should_fail)]\nfn test_merkle_proof_wrong_sibling_fails() {\n    let leaf0 = compute_commitment(100, 1, 1);\n    let leaf1 = compute_commitment(200, 2, 2);\n    let leaf2 = compute_commitment(300, 3, 3);\n    let leaf3 = compute_commitment(400, 4, 4);\n\n    let node1 = pedersen_hash([leaf2, leaf3]);\n    let node0 = pedersen_hash([leaf0, leaf1]);\n    let root = pedersen_hash([node0, node1]);\n\n    let computed = verify_merkle_proof(leaf0, 0, [leaf2, node1], [0, 0]);\n    assert(computed == root);\n}\n\nfn build_tree_depth_2(l0: Field, l1: Field, l2: Field, l3: Field) -> (Field, Field, Field) {\n    let node0 = pedersen_hash([l0, l1]);\n    let node1 = pedersen_hash([l2, l3]);\n    let root = pedersen_hash([node0, node1]);\n    (root, node0, node1)\n}\n\n#[test]\nfn test_transfer_with_dummy_input() {\n    let a_owner = 1;\n    let b_owner = 2;\n    let fee = 0;\n\n    let a_secret = 111;\n    let a_value = 1000;\n    let a_commitment = compute_commitment(a_value, a_secret, a_owner);\n\n    let filler = compute_commitment(500, 999, 99);\n    let (root, _node0, node1) = build_tree_depth_2(a_commitment, filler, filler, filler);\n\n    let computed_root = verify_merkle_proof(a_commitment, 0, [filler, node1], [0, 0]);\n    assert(computed_root == root);\n\n    let null_1 = compute_nullifier(a_secret, 0);\n\n    let dummy_secret = 77777;\n    let dummy_index = 99999;\n    let null_2 = compute_nullifier(dummy_secret, dummy_index);\n    assert(null_1 != null_2);\n\n    let out_value_1 = 1000;\n    let out_value_2 = 0;\n    assert(a_value + 0 == out_value_1 + out_value_2 + fee);\n\n    let b_secret = 222;\n    let change_secret = 333;\n    let _out_comm_1 = compute_commitment(out_value_1, b_secret, b_owner);\n    let _out_comm_2 = compute_commitment(out_value_2, change_secret, a_owner);\n}\n\n#[test]\nfn test_transfer_with_relayer_fee() {\n    let a_owner = 1;\n    let b_owner = 2;\n    let relayer_addr = 0xdead;\n    let fee = 50;\n\n    let a_secret = 111;\n    let a_value = 1000;\n    let a_commitment = compute_commitment(a_value, a_secret, a_owner);\n\n    let filler = compute_commitment(500, 999, 99);\n    let (root, _node0, node1) = build_tree_depth_2(a_commitment, filler, filler, filler);\n\n    let computed_root = verify_merkle_proof(a_commitment, 0, [filler, node1], [0, 0]);\n    assert(computed_root == root);\n\n    let null_1 = compute_nullifier(a_secret, 0);\n    let null_2 = compute_nullifier(77777, 99999);\n    assert(null_1 != null_2);\n\n    let out_value_1 = 950;\n    let out_value_2 = 0;\n    assert(a_value + 0 == out_value_1 + out_value_2 + fee);\n\n    assert(relayer_addr == 0xdead);\n\n    let _out_comm_1 = compute_commitment(out_value_1, 222, b_owner);\n    let _out_comm_2 = compute_commitment(out_value_2, 333, a_owner);\n}\n\n#[test]\nfn test_partial_transfer_with_relayer_fee() {\n    let a_owner = 1;\n    let b_owner = 2;\n    let fee = 50;\n\n    let a_value = 1000;\n    let out_to_b = 600;\n    let change = 350;\n\n    assert(a_value + 0 == out_to_b + change + fee);\n\n    let _comm_b = compute_commitment(out_to_b, 222, b_owner);\n    let _comm_change = compute_commitment(change, 333, a_owner);\n}\n\n#[test(should_fail)]\nfn test_relayer_cannot_inflate_fee() {\n    let input_total = 1000;\n    let out_total = 950;\n    let honest_fee = 50;\n    let inflated_fee = 100;\n\n    assert(input_total == out_total + honest_fee);\n    assert(input_total == out_total + inflated_fee);\n}\n\n#[test]\nfn test_split_inside_pool() {\n    let a_owner = 1;\n    let a_secret = 111;\n    let a_value = 1000;\n    let a_commitment = compute_commitment(a_value, a_secret, a_owner);\n\n    let filler = compute_commitment(0, 0, 0);\n    let (root, _node0, node1) = build_tree_depth_2(a_commitment, filler, filler, filler);\n\n    let computed_root = verify_merkle_proof(a_commitment, 0, [filler, node1], [0, 0]);\n    assert(computed_root == root);\n\n    let out_1 = 700;\n    let out_2 = 300;\n    let fee = 0;\n    assert(a_value + 0 == out_1 + out_2 + fee);\n\n    let new_secret_1 = 444;\n    let new_secret_2 = 555;\n    let out_comm_1 = compute_commitment(out_1, new_secret_1, a_owner);\n    let out_comm_2 = compute_commitment(out_2, new_secret_2, a_owner);\n    assert(out_comm_1 != out_comm_2);\n}\n\n#[test]\nfn test_merge_two_notes() {\n    let b_owner = 2;\n\n    let secret_1 = 222;\n    let secret_2 = 333;\n    let note_1 = compute_commitment(700, secret_1, b_owner);\n    let note_2 = compute_commitment(300, secret_2, b_owner);\n\n    let filler = compute_commitment(0, 0, 0);\n    let (root, _node0, node1) = build_tree_depth_2(note_1, note_2, filler, filler);\n\n    let root_1 = verify_merkle_proof(note_1, 0, [note_2, node1], [0, 0]);\n    assert(root_1 == root);\n\n    let root_2 = verify_merkle_proof(note_2, 1, [note_1, node1], [1, 0]);\n    assert(root_2 == root);\n\n    let null_1 = compute_nullifier(secret_1, 0);\n    let null_2 = compute_nullifier(secret_2, 1);\n    assert(null_1 != null_2);\n\n    let merged_value = 1000;\n    let zero_change = 0;\n    let fee = 0;\n    assert(700 + 300 == merged_value + zero_change + fee);\n\n    let merged_secret = 666;\n    let zero_secret = 777;\n    let out_comm_1 = compute_commitment(merged_value, merged_secret, b_owner);\n    let out_comm_2 = compute_commitment(zero_change, zero_secret, b_owner);\n    assert(out_comm_1 != out_comm_2);\n}\n\n#[test]\nfn test_full_privacy_flow() {\n    let a_owner = 1;\n    let b_owner = 2;\n    let filler = compute_commitment(0, 0, 0);\n\n    let a_secret = 100;\n    let a_note = compute_commitment(13700, a_secret, a_owner);\n    let (root_1, _n0, node1_1) = build_tree_depth_2(a_note, filler, filler, filler);\n\n    let check_root = verify_merkle_proof(a_note, 0, [filler, node1_1], [0, 0]);\n    assert(check_root == root_1);\n\n    let split_secret_1 = 201;\n    let split_secret_2 = 202;\n    assert(13700 == 10000 + 3700);\n\n    let split_note_1 = compute_commitment(10000, split_secret_1, a_owner);\n    let split_note_2 = compute_commitment(3700, split_secret_2, a_owner);\n\n    let b_secret_1 = 301;\n    let b_note_1 = compute_commitment(10000, b_secret_1, b_owner);\n    let change_secret_1 = 302;\n    let _change_1 = compute_commitment(0, change_secret_1, a_owner);\n    assert(10000 + 0 == 10000 + 0);\n\n    let b_secret_2 = 401;\n    let b_note_2 = compute_commitment(3700, b_secret_2, b_owner);\n    assert(3700 + 0 == 3700 + 0);\n\n    let merged_secret = 501;\n    let merged_note = compute_commitment(13700, merged_secret, b_owner);\n    assert(10000 + 3700 == 13700 + 0);\n\n    assert(a_note != split_note_1);\n    assert(split_note_1 != split_note_2);\n    assert(b_note_1 != b_note_2);\n    assert(merged_note != a_note);\n    assert(merged_note != b_note_1);\n\n    let final_secret_1 = 601;\n    let final_secret_2 = 602;\n    let _withdraw_1 = compute_commitment(8000, final_secret_1, b_owner);\n    let _withdraw_2 = compute_commitment(5700, final_secret_2, b_owner);\n    assert(13700 == 8000 + 5700);\n}\n\n#[test]\nfn test_spend_then_respend_produces_different_nullifiers() {\n    let secret = 67890;\n    let nullifier_at_0 = compute_nullifier(secret, 0);\n    let nullifier_at_5 = compute_nullifier(secret, 5);\n    assert(nullifier_at_0 != nullifier_at_5);\n}\n\n#[test(should_fail)]\nfn test_balance_mismatch_detected() {\n    let input_total = 1000;\n    let output_total = 1001;\n    assert(input_total == output_total);\n}\n","path":"/Users/nevvdevv/Development/hackathons/ethoxford-2026/neobank/noir/src/internal_transfer.nr"},"51":{"source":"mod internal_transfer;\n\nuse internal_transfer::{compute_commitment, compute_nullifier, verify_merkle_proof, compute_encrypted_value};\n\n// 2-in-2-out Private Transaction Circuit with Relayer Support\n//\n// Supports all pool operations with a single circuit:\n//   Transfer: note(X, A) + dummy      -> note(X, B) + note(0, _)\n//   Split:    note(X, A) + dummy      -> note(Y, A) + note(X-Y, A)\n//   Merge:    note(X, A) + note(Y, A) -> note(X+Y, A) + note(0, _)\n//   Mixed:    note(X, A) + note(Y, A) -> note(Z, B) + note(X+Y-Z, A)\n\nglobal TREE_DEPTH: u32 = 20;\n\nfn main(\n    // --- public inputs (9 fields visible on-chain) ---\n    merkle_root: pub Field,\n    nullifier_1: pub Field,\n    nullifier_2: pub Field,\n    out_commitment_1: pub Field,\n    out_commitment_2: pub Field,\n    fee: pub Field,\n    relayer: pub Field,\n    encrypted_value_1: pub Field,\n    encrypted_value_2: pub Field,\n\n    // --- input note 1 ---\n    in_value_1: Field,\n    in_secret_1: Field,\n    in_owner_1: Field,\n    in_leaf_index_1: Field,\n    in_path_1: [Field; TREE_DEPTH],\n    in_dirs_1: [Field; TREE_DEPTH],\n    in_is_dummy_1: Field,\n\n    // --- input note 2 ---\n    in_value_2: Field,\n    in_secret_2: Field,\n    in_owner_2: Field,\n    in_leaf_index_2: Field,\n    in_path_2: [Field; TREE_DEPTH],\n    in_dirs_2: [Field; TREE_DEPTH],\n    in_is_dummy_2: Field,\n\n    // --- output note 1 ---\n    out_value_1: Field,\n    out_secret_1: Field,\n    out_owner_1: Field,\n\n    // --- output note 2 ---\n    out_value_2: Field,\n    out_secret_2: Field,\n    out_owner_2: Field,\n\n    // --- viewing keys (for auditor decryption) ---\n    out_viewing_key_1: Field,\n    out_viewing_key_2: Field,\n) {\n    // ========== Input 1 ==========\n    assert((in_is_dummy_1 == 0) | (in_is_dummy_1 == 1), \"Dummy flag must be 0 or 1\");\n\n    let commitment_1 = compute_commitment(in_value_1, in_secret_1, in_owner_1);\n    let root_1 = verify_merkle_proof(commitment_1, in_leaf_index_1, in_path_1, in_dirs_1);\n\n    assert((in_is_dummy_1 == 1) | (root_1 == merkle_root), \"Input 1: Merkle proof invalid\");\n    assert((in_is_dummy_1 == 0) | (in_value_1 == 0), \"Dummy input 1 must have zero value\");\n\n    let computed_null_1 = compute_nullifier(in_secret_1, in_leaf_index_1);\n    assert(computed_null_1 == nullifier_1, \"Input 1: nullifier mismatch\");\n\n    // ========== Input 2 ==========\n    assert((in_is_dummy_2 == 0) | (in_is_dummy_2 == 1), \"Dummy flag must be 0 or 1\");\n\n    let commitment_2 = compute_commitment(in_value_2, in_secret_2, in_owner_2);\n    let root_2 = verify_merkle_proof(commitment_2, in_leaf_index_2, in_path_2, in_dirs_2);\n\n    assert((in_is_dummy_2 == 1) | (root_2 == merkle_root), \"Input 2: Merkle proof invalid\");\n    assert((in_is_dummy_2 == 0) | (in_value_2 == 0), \"Dummy input 2 must have zero value\");\n\n    let computed_null_2 = compute_nullifier(in_secret_2, in_leaf_index_2);\n    assert(computed_null_2 == nullifier_2, \"Input 2: nullifier mismatch\");\n\n    // ========== Cross-input checks ==========\n    assert(nullifier_1 != nullifier_2, \"Duplicate nullifier\");\n\n    // ========== Balance conservation ==========\n    // inputs = outputs + fee (fee goes to relayer as gas compensation)\n    let total_in = in_value_1 + in_value_2;\n    let total_out = out_value_1 + out_value_2;\n    assert(total_in == total_out + fee, \"Amounts do not balance\");\n\n    out_value_1.assert_max_bit_size::<126>();\n    out_value_2.assert_max_bit_size::<126>();\n    fee.assert_max_bit_size::<126>();\n\n    // ========== Output commitments ==========\n    let computed_out_1 = compute_commitment(out_value_1, out_secret_1, out_owner_1);\n    assert(computed_out_1 == out_commitment_1, \"Output 1: commitment mismatch\");\n\n    let computed_out_2 = compute_commitment(out_value_2, out_secret_2, out_owner_2);\n    assert(computed_out_2 == out_commitment_2, \"Output 2: commitment mismatch\");\n\n    // ========== Viewing key encryption ==========\n    let computed_enc_1 = compute_encrypted_value(out_value_1, out_viewing_key_1, out_commitment_1);\n    assert(computed_enc_1 == encrypted_value_1, \"Encrypted value 1 mismatch\");\n\n    let computed_enc_2 = compute_encrypted_value(out_value_2, out_viewing_key_2, out_commitment_2);\n    assert(computed_enc_2 == encrypted_value_2, \"Encrypted value 2 mismatch\");\n}","path":"/Users/nevvdevv/Development/hackathons/ethoxford-2026/neobank/noir/src/main.nr"}},"names":["main"],"brillig_names":["decompose_hint","directive_invert"]}